# SMS 로거 개발 계획

## 1. 개요 및 목적
메신저 형태로 SMS 기록을 볼 수 있는 어드민 페이지를 개발합니다. 사용자들 간의 SMS 통신 내역을 효과적으로 조회하고 관리할 수 있는 인터페이스를 제공합니다.

## 2. 시스템 구성요소

### 2.1 백엔드 요구사항
- 전체 SMS 로그를 조회하는 GraphQL 쿼리 개발 필요
- 기존 SmsLog 모델 활용

### 2.2 프론트엔드 요구사항
- `SmsLogger.jsx` 컴포넌트 신규 개발
- 로컬 캐싱 구현
- 3분할 레이아웃 (유저/전화번호 목록, 대화 상대 목록, 대화 내역)
- 검색 기능
- 엑셀 저장 기능

## 3. 개발 단계

### 3.1 백엔드 개발
1. GraphQL 스키마 확장
   - 전체 SMS 로그 조회 쿼리 추가
   - 필요한 필터링 옵션 구현

2. 리졸버 구현
   - 효율적인 데이터 조회 로직 구현
   - 대량 데이터 처리 최적화

### 3.2 프론트엔드 개발
1. 기본 컴포넌트 구조 설계
2. 로컬 캐싱 메커니즘 구현
3. UI 레이아웃 구현
4. 데이터 조회 및 표시 로직 구현
5. 검색 기능 구현
6. 엑셀 저장 기능 구현

### 3.3 테스트
1. 기능 테스트
2. 성능 테스트 (대량 데이터 처리)
3. UI/UX 테스트

## 4. 상세 구현 계획

### 4.1 백엔드 API 설계

#### GraphQL 스키마 확장
```graphql
type Query {
  # 기존 쿼리...
  getAllSmsLogs: [SmsLog!]!  # 전체 SMS 로그 조회
}
```

#### 리졸버 구현
- 효율적인 데이터베이스 쿼리 구현
- 필요 시 페이지네이션 도입 검토

### 4.2 프론트엔드 컴포넌트 설계

#### 리셋 기능
- 선택한 유저/전화번호 및 대화 상대 초기화
- 검색 조건 초기화
- 화면에 표시된 대화 내역 초기화
- 모든 선택 상태를 초기 상태로 복원

#### SmsLogger.jsx 구조
- 메인 컨테이너 컴포넌트
- 헤더 컴포넌트 (로드 버튼, 캐시 시간 표시, 리셋 버튼)
- 검색 컴포넌트
- 3분할 레이아웃 컴포넌트:
  - 유저/번호 목록 컴포넌트
  - 대화 상대 목록 컴포넌트
  - 대화 내역 컴포넌트
- 저장 기능 컴포넌트

#### 로컬 캐싱 구현
- Apollo Client 캐시 활용
- 로컬 스토리지 또는 인메모리 캐싱 구현
- 캐시 갱신 메커니즘 구현

#### UI 레이아웃
- 유저 기반 탭과 전화번호 기반 탭을 통합한 단일 인터페이스 설계
- 좌측: 유저/전화번호 리스트 (토글 또는 탭으로 전환)
- 중앙: 대화 상대 리스트
- 우측: 대화 내역 타임라인

#### 리스트 아이템 상태 관리
- 각 리스트 아이템은 3가지 상태를 가짐:
  1. **선택 상태**: 현재 사용자가 선택한 아이템 (강조 표시)
  2. **활성화 상태**: 선택된 아이템과 관련하여 데이터가 존재하는 아이템 (검정색)
  3. **비활성화 상태**: 선택된 아이템과 관련된 데이터가 없는 아이템 (회색)

#### 인터랙션 플로우
1. **초기 상태**: 
   - 모든 아이템이 비활성화 상태로 시작
   
2. **리스트 아이템 선택 시**:
   - **검색 필드 초기화**: 검색으로 필터링된 상태에서 아이템 선택 시 해당 리스트의 검색 필드 초기화
   - 선택한 아이템이 선택 상태로 변경
   - 선택한 아이템과 관련 데이터가 있는 다른 리스트의 아이템들은 활성화 상태로 변경
   - 관련 데이터가 없는 아이템들은 비활성화 상태로 유지
   
3. **비활성화된 아이템 선택 시**:
   - 기존 선택된 모든 아이템의 선택 상태 리셋
   - 모든 검색 필드 초기화 (검색 조건 리셋)
   - 새로 선택한 아이템을 선택 상태로 변경
   - 새로운 선택에 기반하여 다른 리스트 아이템들의 활성화/비활성화 상태 재계산

4. **실제 사용 시나리오**:
   - **일반 선택 흐름**: 사용자가 "테라피" 유저 선택 → 대화내역이 있는 "1111", "33333" 번호 활성화, "2222" 비활성화
   - **비활성화 아이템 선택**: 비활성화된 "2222" 선택 시 → "테라피" 선택 해제 → "마사지", "오링" 활성화 (대화내역 있는 유저)
   - **검색 후 선택**: 전화번호에서 "111"로 검색 → "1111", "1112" 등 표시 → "1111" 선택 시 → 검색 필드 초기화 → "1111" 선택 상태 → 관련 유저들 활성화

#### 검색 기능
- 각 리스트(좌측, 중앙, 우측) 상단에 독립적인 검색 필드 구현
- 리스트별 검색 처리 방식:
  1. **좌측 리스트(유저/전화번호)**:
     - 유저명 또는 전화번호로 검색
     - 검색 결과에 맞는 항목만 표시하되, 활성화/비활성화/선택 상태는 유지
     - 검색어 입력 시 실시간 필터링
  
  2. **중앙 리스트(대화 상대)**:
     - 좌측에서 선택된 항목과 관련된 대화 상대 중에서 검색
     - 이름 또는 전화번호로 필터링
     - 검색 결과가 없으면 "검색 결과 없음" 표시
  
  3. **우측 리스트(대화 내역)**:
     - 대화 내용 키워드 검색
     - 날짜 범위 검색 기능 제공
     - 검색 결과 하이라이트 표시
     - 키워드 일치 대화로 스크롤 기능

- 검색 필드 초기화 방법:
  - 각 검색 필드에 'X' 버튼 제공
  - 리셋 버튼 클릭 시 모든 검색 필드 초기화

#### 엑셀 저장 기능
- 기존 UserLogsDialog와 UserPhoneRecordsDialog의 저장 로직 참고
- 필터링된 데이터의 선택적 저장 기능
- 저장 형식 및 옵션 제공

### 4.3 데이터 흐름
1. 로드 버튼 클릭 → GraphQL 쿼리 실행
2. 받은 데이터를 로컬 캐시에 저장
3. 유저/전화번호 선택 시:
   - 해당 리스트의 검색 필드 초기화 (검색 조건 리셋)
   - 선택된 아이템과 관련된 데이터 필터링
   - 다른 리스트의 아이템들 활성화/비활성화 상태 업데이트
   - 관련 대화 내역 표시
4. 비활성화 아이템 선택 시:
   - 기존 선택 상태 리셋
   - 모든 검색 필드 초기화
   - 새로운 선택 기준으로 데이터 재필터링
   - 새로운 기준에 따른 활성화/비활성화 상태 업데이트
5. 검색 시 로컬 캐시 데이터 필터링하되, 활성화/비활성화/선택 상태 유지

## 5. 테스트 계획
1. 단위 테스트
   - 각 컴포넌트 기능 테스트
   - API 응답 테스트

2. 통합 테스트
   - 전체 워크플로우 테스트
   - 데이터 흐름 테스트

3. 성능 테스트
   - 대량 데이터 처리 시 성능 확인
   - 캐싱 효율성 테스트

## 6. 개선 가능 사항
1. 무한 스크롤 또는 가상화 목록 구현 (대량 데이터 처리)
2. 메시지 그룹화 기능
3. 대화 내용 검색 기능
4. 대화 컨텍스트 시각화

## 7. 예상 일정
1. 백엔드 개발: 1-2일
2. 프론트엔드 기본 구조 개발: 2-3일
3. UI 구현 및 데이터 연동: 2-3일
4. 검색 및 저장 기능 구현: 1-2일
5. 테스트 및 버그 수정: 1-2일

총 예상 소요 시간: 7-12일 (개발자 숙련도 및 기존 코드 복잡성에 따라 변동 가능)